using Algorand.Algod.Model;
using Algorand.Algod.Model.Transactions;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"

namespace TEALDebugAdapterComponent
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface ISimulateApi
    {


        /// <summary>
        /// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
        /// </summary>
        /// <param name="format">Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.</param>
        /// <param name="body">The transactions to simulate, along with any other inputs.</param>
        /// <returns>Result of a transaction group simulation.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SimulateResponse> SimulateTransactionAsync(Format12? format, SimulateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
        /// </summary>
        /// <param name="format">Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.</param>
        /// <param name="body">The transactions to simulate, along with any other inputs.</param>
        /// <returns>Result of a transaction group simulation.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SimulateResponse> SimulateTransactionAsync(Format12? format, SimulateRequest body, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SimulateApi : ISimulateApi
    {
        private string _baseUrl = "http://localhost/";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public SimulateApi(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);






        /// <summary>
        /// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
        /// </summary>
        /// <param name="format">Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.</param>
        /// <param name="body">The transactions to simulate, along with any other inputs.</param>
        /// <returns>Result of a transaction group simulation.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SimulateResponse> SimulateTransactionAsync(Format12? format, SimulateRequest body)
        {
            return SimulateTransactionAsync(format, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
        /// </summary>
        /// <param name="format">Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.</param>
        /// <param name="body">The transactions to simulate, along with any other inputs.</param>
        /// <returns>Result of a transaction group simulation.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SimulateResponse> SimulateTransactionAsync(Format12? format, SimulateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/transactions/simulate?");
            if (format != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("format") + "=").Append(System.Uri.EscapeDataString(ConvertToString(format, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    //var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
                    //var content_ = new System.Net.Http.StringContent(json_);
                    System.Net.Http.ByteArrayContent content_ = new System.Net.Http.ByteArrayContent(Algorand.Utils.Encoder.EncodeToMsgPackOrdered(body));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/msgpack");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SimulateResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Invalid API Token", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Internal Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Service Temporarily Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unknown Error", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }



        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }



    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SimulateResponse
    {
        [Newtonsoft.Json.JsonProperty("eval-overrides", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SimulationEvalOverrides EvalOverrides { get; set; }

        [Newtonsoft.Json.JsonProperty("exec-trace-config", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SimulateTraceConfig ExecTraceConfig { get; set; }

        /// <summary>
        /// The round immediately preceding this simulation. State changes through this round were used to run this simulation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last-round", Required = Newtonsoft.Json.Required.Always)]
        public int LastRound { get; set; }

        /// <summary>
        /// A result object for each transaction group that was simulated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("txn-groups", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SimulateTransactionGroupResult> TxnGroups { get; set; } = new System.Collections.Generic.List<SimulateTransactionGroupResult>();

        /// <summary>
        /// The version of this response object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static SimulateResponse FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<SimulateResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    public partial class SimulateTransactionGroupResult
    {
        [JsonProperty("app-budget-added", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)]
        public ulong? AppBudgetAdded { get; set; }

        [JsonProperty("app-budget-consumed", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)]
        public ulong? AppBudgetConsumed { get; set; }

        [JsonProperty("failed-at", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)]
        public ICollection<ulong> FailedAt { get; set; } = new Collection<ulong>();


        [JsonProperty("failure-message", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)]
        public string FailureMessage { get; set; }

        [JsonProperty("txn-results", Required = Required.Always)]
        [Required]
        public ICollection<SimulateTransactionResult> TxnResults { get; set; } = new Collection<SimulateTransactionResult>();

    }

   
    /// <summary>
    /// Simulation result for an individual transaction
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SimulateTransactionResult
    {
        /// <summary>
        /// Budget used during execution of an app call transaction. This value includes budged used by inner app calls spawned by this transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("app-budget-consumed", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int AppBudgetConsumed { get; set; }

        [Newtonsoft.Json.JsonProperty("exec-trace", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SimulationTransactionExecTrace ExecTrace { get; set; }

        /// <summary>
        /// Budget used during execution of a logic sig transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("logic-sig-budget-consumed", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int LogicSigBudgetConsumed { get; set; }

        [Newtonsoft.Json.JsonProperty("txn-result", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IReturnableTransaction TxnResult { get; set; } 

        [Newtonsoft.Json.JsonProperty("unnamed-resources-accessed", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SimulateUnnamedResourcesAccessed UnnamedResourcesAccessed { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static SimulateTransactionResult FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<SimulateTransactionResult>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    /// <summary>
    /// These are resources that were accessed by this group that would normally have caused failure, but were allowed in simulation. Depending on where this object is in the response, the unnamed resources it contains may or may not qualify for group resource sharing. If this is a field in SimulateTransactionGroupResult, the resources do qualify, but if this is a field in SimulateTransactionResult, they do not qualify. In order to make this group valid for actual submission, resources that qualify for group sharing can be made available by any transaction of the group; otherwise, resources must be placed in the same transaction which accessed them.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SimulateUnnamedResourcesAccessed
    {
        /// <summary>
        /// The unnamed accounts that were referenced. The order of this array is arbitrary.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accounts", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Accounts { get; set; }

        /// <summary>
        /// The unnamed application local states that were referenced. The order of this array is arbitrary.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("app-locals", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApplicationLocalReference> AppLocals { get; set; }

        /// <summary>
        /// The unnamed applications that were referenced. The order of this array is arbitrary.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apps", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<int> Apps { get; set; }

        /// <summary>
        /// The unnamed asset holdings that were referenced. The order of this array is arbitrary.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("asset-holdings", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AssetHoldingReference> AssetHoldings { get; set; }

        /// <summary>
        /// The unnamed assets that were referenced. The order of this array is arbitrary.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("assets", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<int> Assets { get; set; }

        /// <summary>
        /// The unnamed boxes that were referenced. The order of this array is arbitrary.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("boxes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BoxReference> Boxes { get; set; }

        /// <summary>
        /// The number of extra box references used to increase the IO budget. This is in addition to the references defined in the input transaction group and any referenced to unnamed boxes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extra-box-refs", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int ExtraBoxRefs { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static SimulateUnnamedResourcesAccessed FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<SimulateUnnamedResourcesAccessed>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    /// <summary>
    /// References a box of an application.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class BoxReference
    {
        /// <summary>
        /// Application ID which this box belongs to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("app", Required = Newtonsoft.Json.Required.Always)]
        public int App { get; set; }

        /// <summary>
        /// Base64 encoded box name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")]
        public byte[] Name { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static BoxReference FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<BoxReference>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    /// <summary>
    /// References an account's local state for an application.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApplicationLocalReference
    {
        /// <summary>
        /// Address of the account with the local state.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("account", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Account { get; set; }

        /// <summary>
        /// Application ID of the local state application.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("app", Required = Newtonsoft.Json.Required.Always)]
        public int App { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static ApplicationLocalReference FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<ApplicationLocalReference>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }


    /// <summary>
    /// References an asset held by an account.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class AssetHoldingReference
    {
        /// <summary>
        /// Address of the account holding the asset.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("account", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Account { get; set; }

        /// <summary>
        /// Asset ID of the holding.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("asset", Required = Newtonsoft.Json.Required.Always)]
        public int Asset { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static AssetHoldingReference FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<AssetHoldingReference>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    /// <summary>
    /// The set of trace information and effect from evaluating a single opcode.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SimulationOpcodeTraceUnit
    {
        /// <summary>
        /// The program counter of the current opcode being evaluated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pc", Required = Newtonsoft.Json.Required.Always)]
        public int Pc { get; set; }

        /// <summary>
        /// The writes into scratch slots.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scratch-changes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ScratchChange> ScratchChanges { get; set; }

        /// <summary>
        /// The indexes of the traces for inner transactions spawned by this opcode, if any.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("spawned-inners", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<int> SpawnedInners { get; set; }

        /// <summary>
        /// The values added by this opcode to the stack.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stack-additions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AvmValue> StackAdditions { get; set; }

        /// <summary>
        /// The number of deleted stack values by this opcode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stack-pop-count", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int StackPopCount { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static SimulationOpcodeTraceUnit FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<SimulationOpcodeTraceUnit>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    /// <summary>
    /// Represents an AVM value.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class AvmValue
    {
        /// <summary>
        /// bytes value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")]
        public byte[] Bytes { get; set; }

        /// <summary>
        /// value type. Value `1` refers to **bytes**, value `2` refers to **uint64**
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        public int Type { get; set; }

        /// <summary>
        /// uint value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uint", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong Uint { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static AvmValue FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<AvmValue>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }


    /// <summary>
    /// A write operation into a scratch slot.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ScratchChange
    {
        [Newtonsoft.Json.JsonProperty("new-value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public AvmValue NewValue { get; set; } = new AvmValue();

        /// <summary>
        /// The scratch slot written.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slot", Required = Newtonsoft.Json.Required.Always)]
        public int Slot { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static ScratchChange FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<ScratchChange>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    /// <summary>
    /// The execution trace of calling an app or a logic sig, containing the inner app call trace in a recursive way.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SimulationTransactionExecTrace
    {
        /// <summary>
        /// Program trace that contains a trace of opcode effects in an approval program.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("approval-program-trace", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SimulationOpcodeTraceUnit> ApprovalProgramTrace { get; set; }

        /// <summary>
        /// Program trace that contains a trace of opcode effects in a clear state program.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("clear-state-program-trace", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SimulationOpcodeTraceUnit> ClearStateProgramTrace { get; set; }

        /// <summary>
        /// An array of SimulationTransactionExecTrace representing the execution trace of any inner transactions executed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inner-trace", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SimulationTransactionExecTrace> InnerTrace { get; set; }

        /// <summary>
        /// Program trace that contains a trace of opcode effects in a logic sig.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("logic-sig-trace", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SimulationOpcodeTraceUnit> LogicSigTrace { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static SimulationTransactionExecTrace FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<SimulationTransactionExecTrace>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }


    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public enum Format12
    {

        [System.Runtime.Serialization.EnumMember(Value = @"json")]
        Json = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"msgpack")]
        Msgpack = 1,

    }

    /// <summary>
    /// Request type for simulation endpoint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SimulateRequest
    {
        /// <summary>
        /// Allows transactions without signatures to be simulated as if they had correct signatures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allow-empty-signatures", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool AllowEmptySignatures { get; set; }

        /// <summary>
        /// Lifts limits on log opcode usage during simulation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allow-more-logging", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool AllowMoreLogging { get; set; }

     

        [Newtonsoft.Json.JsonProperty("exec-trace-config", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SimulateTraceConfig ExecTraceConfig { get; set; }

        /// <summary>
        /// Applies extra opcode budget during simulation for each transaction group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extra-opcode-budget", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int ExtraOpcodeBudget { get; set; }

        /// <summary>
        /// The transaction groups to simulate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("txn-groups", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SimulateRequestTransactionGroup> TxnGroups { get; set; } = new System.Collections.Generic.List<SimulateRequestTransactionGroup>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static SimulateRequest FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<SimulateRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

    /// <summary>
    /// The set of parameters and limits override during simulation. If this set of parameters is present, then evaluation parameters may differ from standard evaluation in certain ways.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SimulationEvalOverrides
    {
        /// <summary>
        /// If true, transactions without signatures are allowed and simulated as if they were properly signed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allow-empty-signatures", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool AllowEmptySignatures { get; set; }

        /// <summary>
        /// If true, allows access to unnamed resources during simulation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allow-unnamed-resources", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool AllowUnnamedResources { get; set; }

        /// <summary>
        /// The extra opcode budget added to each transaction group during simulation
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extra-opcode-budget", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int ExtraOpcodeBudget { get; set; }

        /// <summary>
        /// The maximum log calls one can make during simulation
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max-log-calls", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int MaxLogCalls { get; set; }

        /// <summary>
        /// The maximum byte number to log during simulation
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max-log-size", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int MaxLogSize { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static SimulationEvalOverrides FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<SimulationEvalOverrides>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    /// <summary>
    /// An object that configures simulation execution trace.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SimulateTraceConfig
    {
        /// <summary>
        /// A boolean option for opting in execution trace features simulation endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Enable { get; set; }

        /// <summary>
        /// A boolean option enabling returning scratch slot changes together with execution trace during simulation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scratch-change", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool ScratchChange { get; set; }

        /// <summary>
        /// A boolean option enabling returning stack changes together with execution trace during simulation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stack-change", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool StackChange { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static SimulateTraceConfig FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<SimulateTraceConfig>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    /// <summary>
    /// A transaction group to simulate.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.5.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SimulateRequestTransactionGroup
    {
        /// <summary>
        /// An atomic transaction group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("txns", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List<SignedTransaction> Txns { get; set; } 

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static SimulateRequestTransactionGroup FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<SimulateRequestTransactionGroup>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }
}